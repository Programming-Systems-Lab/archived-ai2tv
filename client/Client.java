/* * @(#)Client.java * * Copyright (c) 2001: The Trustees of Columbia University in the City of New York.  All Rights Reserved * * Copyright (c) 2001: @author Dan Phung * Last modified by: Dan Phung (dp2041@cs.columbia.edu) * * CVS version control block - do not edit manually *  $RCSfile$ *  $Revision$ *  $Date$ *  $Source$ */package psl.ai2tv.client;import java.io.*;import java.util.*;import psl.ai2tv.gauge.*;import psl.ai2tv.SienaConstants;/** * Main component controlling the others.  commPlay is where the main * fun starts.  after receiving a play message, the client will start * the viewing thread.  checkCurrentFrame() is the main function that * checks what time it is, what frame we should be showing, etc.  The * client only responds after receiving a play command from the Siena * server, which calls commPlay to start the viewing. * *         /---------------------> <--Siena--> --> other clients *        / * [CommController] *     /\ *     |     /-------> [ ClientProbe ] <--Siena--> WF |    / /------< [ ClientEffector ] <--Siena--> WF *     |   / / *     \/ / \/ *   [ Client ] <------> [CacheController] *      /\   *       \    *        \    *        \/ *      [Viewer] * * * WF related probes: * 0) * * * * * @version	$REvision: $ * @author	Dan Phung (dp2041@cs.columbia.edu) */class Client {  // this private class is declared here temporarily to separate the  // dependency on the C++ side of things, for testing and development  // purposes  private class AI2TVJNIJava {  }  // output streams for debugging info  public static PrintStream out;  public static PrintStream err;  public static PrintStream debug;  public static PrintStream probeOutput;  private AI2TVJNIJava _JNIIntf;  private CacheController _cache;  private CommController _comm;  private Viewer _viewer;  private TimeController _clock;  /** current download/viewing hierarchy level */  private int _level;  /** the time it takes for the WF to contact us */  private int _wfDistance;  private boolean _isActive;  private FrameIndexParser _framesInfo;  private FrameDesc[][] _framesData;  private long _id; // client id number for server identification  // we need a three frame window in order to be able to detect missed frames  private FrameDesc _currFrame;  private FrameDesc _nextFrame;  private FrameDesc _neededFrame;  private long _timeCurrFrameShown;  // time that the current image was first shown  // we should have these in a config file  public static final String _cacheDir = "cache/";  // public static final String _baseURL = "http://franken.psl.cs.columbia.edu/ai2tv/1/";  // public static final String _sienaServer = "ka:franken:4444";  public static final String _baseURL = "http://128.59.14.163/ai2tv/1/";  public static final String _sienaServer = System.getProperty("ai2tv.server"); //"ka:128.59.14.163:4444";  public static final String _frameFile = "frame_index.txt";  public static final long FRAME_RATE = 30; // frames / second  public static final long CHECK_RATE = 250; // check if frame is downloaded this often (ms)  /**   * this the amount of buffer time I give to allow processing   * delays (lookahead ~ time to process what image to show +   * time to load and paint image) in seconds   */  private long _lookahead = 0;  /**   * WF Probe   */  static ClientProbe probe;  /**   * WF Effector   */  private ClientEffector _effector;  /**   * Create an AI2TV Client   */  Client() {    // promptUser();        try {      out = new PrintStream(new FileOutputStream(new File("ai2tv_out.log")), true);      err = new PrintStream(new FileOutputStream(new File("ai2tv_err.log")), true);    } catch (IOException e) {      e.printStackTrace();    }     debug = System.out;    probeOutput = out;    // make sure that the base url and cache dir names end with a slash    checkEndWithSlash(_baseURL);    checkEndWithSlash(_cacheDir);    // what is the prob that two clients are created at the exact same    // time? ...pretty low.  though, we should maybe encrypt later on    // if we want security.    _id = System.currentTimeMillis();    _level = 0;    _timeCurrFrameShown = 0;    _cache = new CacheController(this, _cacheDir, _baseURL);    checkFrameFile(_frameFile);    _framesInfo = new FrameIndexParser(_cacheDir + _frameFile);    _framesData = _framesInfo.frameData();    _clock = new TimeController();    _viewer = new Viewer(this);    _comm = new CommController(this, _id, _sienaServer);    if (!_comm.isActive()) {      System.out.println("Error creating CommController");      System.exit(1);    }    _cache.initialize(); // start the thread to download frames    _cache.start(); // start the thread to download frames    _currFrame = null;    _nextFrame = null;    _neededFrame = null;    probe = new ClientProbe(this, _sienaServer, 10); // we will have 10 probes set    _effector = new ClientEffector(this, _sienaServer);  }  /**   * check that the frame file is downloaded.  if not, go get it.   *   * @param frameFile: exact path/filename of the frame index file   */  private void checkFrameFile(String frameFile) {    File fh = new File(_cacheDir + frameFile);    if (fh == null || !fh.exists()) {      _cache.downloadFile(_baseURL + frameFile);    }  }  /**   * check that the given filename/URL ends in a forward slash   *   * @param filename: filename/URL to check   */  private void checkEndWithSlash(String filename){    if (!filename.endsWith("/"))      filename = filename + "/";  }  /**   * @return initialized FrameIndexParser data structure   */  FrameIndexParser getFramesInfo() {    return _framesInfo;  }  /**   * @return frame that should be playing right now   */  private FrameDesc getFrame(int level, long now) {    double currentTime = (double) now / 1000;    // Client.debug.print("frame to show right now: " + "(" + currentTime + ") : < ");    for (int i = 0; i < _framesData[level].length; i++) {      // Client.out.println("< " + (_framesData[level][i].getStart()/30) + " ? " + currentTime +      // " ? " + _framesData[level][i].getEnd()/30 + ">");      if ((double)_framesData[level][i].getStart() / 30 <= currentTime &&	  currentTime < (double)_framesData[level][i].getEnd()/30) {		// Client.debug.println(_framesData[level][i].getStart()/(double)30 + ", " + 	// _framesData[level][i].getEnd()/(double)30 + "> : " + _framesData[level][i].getNum());	return _framesData[level][i];      }    }    return null;  }  /**   * @return the clock's current time   */  public long currentTime() {    return _clock.currentTime();  }  /**   * @return time the video ends at   */  int videoEndTime() {    return (_framesData[0][_framesData[0].length - 1].getEnd() / 30 + 1);  }  /**   * @return whether the client is active   */  boolean isActive() {    return _isActive;  }  /**   * shutdown the client   */  void shutdown() {    _isActive = false;  }  /**   * @return client's ID, which is the currently time of creation   */  long getID() {    return _id;  }  /**   * @return client's current bandwidth   */  double getBandwidth() {    return _cache.getBandwidth();  }  /**   * @return time that the current frame was originally shown   */  long getTimeCurrFrameShown() {    return _timeCurrFrameShown;  }  /**   * @return current level of the client   */  public int getLevel() {    return _level;  }  /**   * @return current frame showing   */  FrameDesc getCurrFrame() {    return _currFrame;  }  /**   * load the image in memory in preparation to be shown   * @param image: image to load   */  void loadImage(String image) {    _viewer.loadImage(image);  }private void promptUser(){  String user = "Dan";  System.out.print("Hi " + user + ", what video do you want to prefetch? ");  LineNumberReader line = new LineNumberReader(new InputStreamReader(System.in));      String video;  String time2get;  try {    video = line.readLine().trim();    if (video == null){      System.out.println("Error, nothing was entered!");      System.exit(0);    }        System.out.print("When would you  like it by? ");    time2get = line.readLine().trim();        if (time2get == null){      System.out.println("nothin was entered!");      System.exit(0);    }        System.out.println("OK, I'll get " + video + " by " + time2get);    } catch (FileNotFoundException e) {      e.printStackTrace();    } catch (IOException e) {      e.printStackTrace();    }}              /**   * starts the viewer playing thread that checks what the current frame should be   */  private void startViewerThread() {    System.out.println("starting viewer thread");    if (!_isActive){      _isActive = true;      new Thread() {	public void run() {	  while (_isActive) {	    checkCurrentFrame();	    try {	      sleep(CHECK_RATE);	    } catch (InterruptedException e) {	      Client.err.println("Client play thread error: " + e);	      shutdown();	    }	  }	}      }.start();    }  }  /**   * checks what time it is + some lookahead factor,   * and checks to see if:   * 1) we missed a frame, in which case we interrupt the current download.   * The cache controller should then start downloading the next frame that it.   * can possible get.   * 2) we haven't yet downloaded the frame that was supposed to be   * showing at this time, so we wait some more   * 3) we've downloaded the frame, so show it.   */  private void checkCurrentFrame() {    _nextFrame = getFrame(_level, currentTime() + _lookahead);    Client.debug.println(Calendar.getInstance().getTime() + ": next frame is: " + _nextFrame);        if (_nextFrame == null) {      Client.out.println("Are we at the end of the Video?");      _isActive = false;      return;    }    // if time has changed, and we need to show a new frame    if (_neededFrame != _nextFrame) {      if (_currFrame != null && _currFrame != _neededFrame) {	Client.out.println("missed a frame!: " + _neededFrame + " interrupting");	probe.endTimeProbe(0, _clock.currentTime(), SienaConstants.TIME_SHOWN);	_cache.interruptDownload();	// in addition to interrupting the download, it should also	// tell it the next frame to download and inform the WF      }      _neededFrame = _nextFrame;    }    if (_currFrame == null || _currFrame.getNum() != _neededFrame.getNum()) {      // need to have a set and unset function      if (!probe.getProbeStatus(0)){	System.out.println("starting probe now: " + _clock.currentTime());	probe.startTimeProbe(0, _clock.currentTime());      }      // Client.out.println("Time is: " + currentTime() + " trying to show frame: " + _neededFrame.getNum());      if (_cache.isDownloaded(_neededFrame.getNum() + ".jpg")) {	// then show it.	Client.debug.println(Calendar.getInstance().getTime() + ": showing new frame: " +_neededFrame.getNum() + ".jpg");	// probe.startTimeProbe(0, (double)_neededFrame.getStart() * 1000 / 30);	_viewer.setNewFrame(true);	_viewer.displayImage(_cacheDir + _neededFrame.getNum() + ".jpg");	// shift the frame window back	_currFrame = _neededFrame;	// from here, the Viewer tries to load in the image, and calls this object's	// imageShown method after the image is actually painted on the screen.      } else {	// check if the file is downloaded	// yes: display it	// no: display filler (waiting for file to download)	//     and in the meanwhile, download the file	//     when the file is here, show it.	_viewer.displayImage("ai2tv_loading.jpg");	Client.debug.println(_neededFrame.getNum() + ".jpg was not downloaded in time for showing!");      }    }    // }  }  // --------- ClientEffector initiated actions ---------- //  /**   * change hierarchy downloading /viewing levels   *   * @param change:   */  public void changeLevel(String change) {    Client.debug.print("Client setting new level: " + change);    if (change.indexOf("UP") != -1) {      if (_level > 0) {	_level--;	Client.debug.println(" : " + _level);      } else {	Client.debug.println(" : no change");      }    } else {      if (_level < (_framesData.length-1)) {	_level++;	Client.debug.println(" : " + _level);      } else {	Client.debug.println(" : no change");      }    }    // if the cache controller's not doing what it's supposed to be doing, interrupt it.    if (_cache.getNextFrame(_level, currentTime()).getNum() != _cache.getCurrFrame().getNum())      _cache.interruptDownload();        Client.debug.println("my new level: " + _level);  }  /**   * tell the cache controller to plan to show this frame.   */  public void planFor(String newFrame) {    Client.out.println("Client planning for frame: " + newFrame);    _cache.planFor(newFrame);  }  // --------- END: ClientEffector initiated actions ---------- //  // --------- Comm initiated actions ---------- //  /**   * CommController's interface to tell the client that a play was pressed   *   * @param absTimeSent: absolute system time at which the command was originally sent   */  public void commPlay(long absTimeSent) {    _clock.startTime(absTimeSent);    startViewerThread();  }  /**   * CommController's interface to tell the client that a stop was pressed   */  public void commStop() {    Client.out.println("commStop received");    _isActive = false;    _clock.reset();  }  /**   * CommController's interface to tell the client that a pause was pressed   *   * @param absTimeSent: absolute system time at which the command was originally sent   */  public void commPause(long absTimeSent) {    Client.out.println("commPause received");    _clock.pauseTime(absTimeSent);  }  /**   * CommController's interface to tell the client that a goto slider action occured   *   * @param absTimeSent: absolute system time at which the command was originally sent   */  public void commGoto(long absTimeSent, int newTime) {    Client.out.println("commGoto received");    _clock.gotoTime(absTimeSent, newTime);  }  // ------- END: Comm initiated actions ------- //  // --------- Viewer initiated actions ---------- //  /**   * send the communications controller the news that everybody   * needs to start playing   */  void playPressed() {    if (!_isActive)      _comm.playPressed();  }  /**   * send the communications controller the news that everybody   * needs to stop   */  void stopPressed() {    if (_isActive)      _comm.stopPressed();  }  /**   * send the communications controller the news that everybody   * needs to pause   */  void pausePressed() {    if (_isActive)      _comm.pausePressed();  }  /**   * send the communications controller the news that everybody   * needs to goto the given time.   *   * @param time: time to goto   */  void gotoPressed(int time) {    _comm.gotoPressed(time);  }  // --------- END: Viewer initiated actions ---------- //  public static void main(String[] args) {    Client c = new Client();  }}