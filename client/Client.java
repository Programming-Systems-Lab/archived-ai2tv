/* * @(#)Client.java * * Copyright (c) 2001: The Trustees of Columbia University in the City of New York.  All Rights Reserved * * Copyright (c) 2001: @author Dan Phung * Last modified by: Dan Phung (dp2041@cs.columbia.edu) * * CVS version control block - do not edit manually *  $RCSfile$ *  $Revision$ *  $Date$ *  $Source$ */package psl.ai2tv.client;import java.io.*;import java.util.*;import psl.ai2tv.gauge.*;import psl.ai2tv.SienaConstants;/** * Main component controlling the others.  commPlay is where the main * fun starts.  after receiving a play message, the client will start * the viewing thread.  checkCurrentFrame() is the main function that * checks what time it is, what frame we should be showing, etc.  The * client only responds after receiving a play command from the Siena * server, which calls commPlay to start the viewing. * *         /---------------------> <--Siena--> --> other clients *        / * [CommController] *     /\ *     |     /-------> [ ClientProbe ] <--Siena--> WF *     |    / /------< [ ClientEffector ] <--Siena--> WF *     |   / / *     \/ / \/ *   [ Client ] <------> [CacheController] *      /\   *       \    *        \    *        \/ *      [Viewer] * * * @version	$REvision: $ * @author	Dan Phung (dp2041@cs.columbia.edu) */public class Client {  // this private class is declared here temporarily to separate the  // dependency on the C++ side of things, for testing and development  // purposes  //private class AI2TVJNIJava {  // }  // output streams for debugging info  String lastTime = "";  public static PrintStream goodness; // added for goodness testing  public static PrintStream out;  public static PrintStream err;  public static PrintStream debug;  public static PrintStream probeOutput;  private AI2TVJNIJava _JNIIntf;  private CacheController _cache;  private CommController _comm;  private Viewer _viewer;  private TimeController _clock;  /** current download/viewing hierarchy level */  private int _level;  /** frames per second, also determines (inversely) the video playing speed */  private int _frameRate;  /** reserved number of frames if the cache and client levels are not the same */  private int _reserveFrames;  /** the time it takes for the WF to contact us */  private int _wfDistance;  private boolean _isActive;  /** indicates whether we are in the middle of adjusting the client */  private boolean _adjustingClient;  private FrameIndexParser _framesInfo;  private FrameDesc[][] _framesData;  private long _id; // client id number for server identification  // we need a three frame window in order to be able to detect missed frames  private FrameDesc _currentFrame;  private FrameDesc _nextFrame;  private FrameDesc _neededFrame;  private long _timeCurrFrameShown;  // time that the current image was first shown  // we should have these in a config file  private String _cacheDir = "cache/";  private String _baseURL = System.getProperty("ai2tv.videoURL");  private String _sienaServer = System.getProperty("ai2tv.server"); //"ka:128.59.14.163:4444";  public static final String _frameFile = "frame_index.txt";  public static final long CHECK_RATE = 250; // check if frame is downloaded this often (ms)  public static final String  IMAGE_FORMAT= ".jpg";  /**   * this the amount of buffer time I give to allow processing   * delays (lookahead ~ time to process what image to show +   * time to load and paint image) in seconds   */  private long _lookahead = 0;  /**   * WF Probe   */  static ClientProbe probe;  /**   * WF Effector   */  private ClientEffector _effector;  /**   * Create an AI2TV Client   */  Client() {    // promptUser();    _frameRate = 30;        try {      goodness = new PrintStream(new FileOutputStream(new File("ai2tv_goodness.log")), true);      goodness.println("SystemTime" + "\t" + "Time" + "\t" + "ClientLevel" + "\t" + "CurentFrame" );      out = new PrintStream(new FileOutputStream(new File("ai2tv_out.log")), true);      err = new PrintStream(new FileOutputStream(new File("ai2tv_err.log")), true);    } catch (IOException e) {      e.printStackTrace();    }     debug = System.out;    probeOutput = out;    // make sure that the base url and cache dir names end with a slash    // checkEndWithSlash(_baseURL);    // checkEndWithSlash(_cacheDir);    if (!_baseURL.endsWith("/"))      _baseURL += "/";    if (!_cacheDir.endsWith("/"))      _cacheDir += "/";        // what is the prob that two clients are created at the exact same    // time? ...pretty low.  though, we should maybe encrypt later on    // if we want security.    _id = System.currentTimeMillis();    _level = 4; // 2 is the middle level, a good starting point for all clients.    _timeCurrFrameShown = 0;    _cache = new CacheController(this, _cacheDir, _baseURL);    checkFrameFile(_frameFile);    _framesInfo = new FrameIndexParser(_cacheDir + _frameFile);    _framesData = _framesInfo.frameData();    _clock = new TimeController();    _comm = new CommController(this, _id, _sienaServer);    _viewer = new Viewer(this);    if (!_comm.isActive()) {      Client.err.println("Error creating CommController");      System.exit(1);    }    _cache.initialize(); // start the thread to download frames    _cache.start(); // start the thread to download frames    _currentFrame = null;    _nextFrame = null;    _neededFrame = null;    probe = new ClientProbe(this, _sienaServer, 10); // we will have up to 10 probes set    _effector = new ClientEffector(this, _sienaServer, probe);  }  /**   * check that the frame file is downloaded.  if not, go get it.   *   * @param frameFile: exact path/filename of the frame index file   */  private void checkFrameFile(String frameFile) {    File fh = new File(_cacheDir + frameFile);    if (fh == null || !fh.exists()) {      _cache.downloadFile(_baseURL + frameFile);    }  }  /**   * check that the given filename/URL ends in a forward slash   *   * @param filename: filename/URL to check   */  private void checkEndWithSlash(String filename){    if (!filename.endsWith("/"))      filename = filename + "/";  }  /**   * @return initialized FrameIndexParser data structure   */  FrameIndexParser getFramesInfo() {    return _framesInfo;  }  /**   * @return frame that should be playing right now   */  private FrameDesc getFrame(int level, long now) {    double currentTime = (double) now / 1000;    // Client.debug.print("frame to show right now: " + "(" + currentTime + ") : < ");    for (int i = 0; i < _framesData[level].length; i++) {      // Client.out.println("< " + (_framesData[level][i].getStart()/_frameRate) + " ? " + currentTime +      // " ? " + _framesData[level][i].getEnd()/_frameRate + ">");      if ((double)_framesData[level][i].getStart() / _frameRate <= currentTime &&	  currentTime < (double)_framesData[level][i].getEnd()/_frameRate) {		// Client.debug.println(_framesData[level][i].getStart()/(double)_frameRate + ", " + 	// _framesData[level][i].getEnd()/(double)_frameRate + "> : " + _framesData[level][i].getNum());	return _framesData[level][i];      }    }    return null;  }  /**   * @return the clock's current time   */  public long currentTime() {    return _clock.currentTime();  }  /**   * @return length of the video in seconds   */  int videoLength() {    return (int) ((_framesData[0][_framesData[0].length - 1].getEnd() / _frameRate) + 1);  }  /**   * @return whether the client is active   */  boolean isActive() {    return _isActive;  }  /**   * shutdown the client   */  void shutdown() {    _cache.shutdown();    _comm.shutdown();    _isActive = false;  }  /**   * @return client's ID, which is the currently time of creation   */  long getID() {    return _id;  }  /**   * @return client's ID, which is the currently time of creation   */  int getFrameRate() {    return _frameRate;  }  /**   * @return client's ID, which is the currently time of creation   */  void setFrameRate(int fr) {    if (fr > 0)      _frameRate = fr;  }  /**   * @return client's current bandwidth   */  double getBandwidth() {    return _cache.getBandwidth();  }  /**   * @return time that the current frame was originally shown   */  long getTimeCurrFrameShown() {    return _timeCurrFrameShown;  }  /**   * @return current level of the client   */  public int getLevel() {    return _level;  }  /**   * @return current level of the client's cache controller   */  public int getCacheLevel() {    return _cache.getLevel();  }  /**   * @return number of prefetched frames in the cache at the client's current level   */  public int getReserveFrames() {    return _reserveFrames;  }  /**   * @param level to check   * @return number of prefetched frames   */  int getNumPrefetchedFrames(int level) {    return _cache.getNumPrefetchedFrames(level);  }  /**   * @return current frame showing   */  FrameDesc getCurrentFrame() {    return _currentFrame;  }  /**   * set the time that the current frame was shown   * @return current frame showing   */  void setCurrentFrameTimeShown(long timeShown) {    if (_currentFrame != null)      _currentFrame.setTimeShown(timeShown);  }  /**   * load the image in memory in preparation to be shown   * @param image: image to load   */  void loadImage(String image) {    // try twice to load the image    if (!_viewer.loadImage(image))      _viewer.loadImage(image);  }  private void promptUser(){    String user = "Dan";    System.out.print("Hi " + user + ", what video do you want to prefetch? ");    LineNumberReader line = new LineNumberReader(new InputStreamReader(System.in));        String video;    String time2get;    try {      video = line.readLine().trim();      if (video == null){	System.out.println("Error, nothing was entered!");	System.exit(0);      }          System.out.print("When would you  like it by? ");      time2get = line.readLine().trim();          if (time2get == null){	System.out.println("nothin was entered!");	System.exit(0);      }          System.out.println("OK, I'll get " + video + " by " + time2get);    } catch (FileNotFoundException e) {      e.printStackTrace();    } catch (IOException e) {      e.printStackTrace();    }  }        /**   * starts the viewer playing thread that checks what the current frame should be   */  private void startViewerThread() {    if (!_isActive){      _isActive = true;      new Thread() {	public void run() {	  while (_isActive) {	    if (!_adjustingClient)	      checkCurrentFrame();	    try {	      sleep(CHECK_RATE);	    } catch (InterruptedException e) {	      Client.err.println("Client play thread error: " + e);	      shutdown();	    }	  }	}      }.start();    }  }  /**   * checks what time it is + some lookahead factor,   * and checks to see if:   * 1) we missed a frame, in which case we interrupt the current download.   * The cache controller should then start downloading the next frame.    * 2) we haven't yet downloaded the frame that was supposed to be   * showing at this time, so we wait some more   * 3) we've downloaded the frame, so show it.   */  private void checkCurrentFrame() {    long now = currentTime();    String thisTime = ((int)(now/60000)) +":"+ ((now/1000)%60);    long systemNow = System.currentTimeMillis();    _nextFrame = getFrame(_level, now + _lookahead);    // Client.debug.println(Calendar.getInstance().getTime() + ": next frame is: " + _nextFrame.getNum());    if (_nextFrame == null) {      Client.out.println("Are we at the end of the Video?");      _isActive = false;      return;    }    // if time has changed, and we need to show a new frame    // if (_neededFrame != _nextFrame) {    // if (_nextFrame.getStart() < _neededFrame.getStart() && !_adjustingClient) {    if (_neededFrame != _nextFrame && !_adjustingClient) {      // if 1) we're not currently showing the frame we need      // 2) the frame we need is not downloaded      // 3) the frame we need is currently trying to be downloaded      if (_currentFrame != null && _currentFrame != _neededFrame && 	  !_cache.isDownloaded(_nextFrame.getNum() + IMAGE_FORMAT))  {	Client.debug.println("missed frame: " + _neededFrame.getNum() + "! interrupted by: " + _nextFrame.getNum());	goodness.println(systemNow + "\t" + thisTime + "\t" + _level + "\t" + "missed: " + _neededFrame.getNum());	probe.endTimeProbe(0, _clock.currentTime(), SienaConstants.AI2TV_FRAME_MISSED);	_cache.interruptDownload(false);      }      _neededFrame = _nextFrame;    }    if (_currentFrame == null || _currentFrame.getNum() != _neededFrame.getNum()) {      if (!probe.getProbeStatus(0)){	probe.startTimeProbe(0, _clock.currentTime());      }      Client.debug.println("Time is: " + ((int)(currentTime()/60000))+":"+((int)(currentTime()/1000)%60) +			   " trying to show frame: " + _neededFrame.getNum());      if (_cache.isDownloaded(_neededFrame.getNum() + IMAGE_FORMAT)) {	// then show it.	Client.debug.println(Calendar.getInstance().getTime() + ": showing new frame: " +_neededFrame.getNum() + IMAGE_FORMAT);	// probe.startTimeProbe(0, (double)_neededFrame.getStart() * 1000 / _frameRate);		_viewer.setNewFrame(true);	if (_viewer.displayImage(_cacheDir + _neededFrame.getNum() + IMAGE_FORMAT)){	  _currentFrame = _neededFrame;	  // if the cache is downloading frames for a different level, then 	  // we need to decrement from that number	  if (_cache.getLevel() != _level)	    _reserveFrames--;	  // from here, the Viewer tries to load in the image, and calls this object's	  // imageShown method after the image is actually painted on the screen.	  	} else {	  ; // we haven't loaded it yet	}      } else {	// _viewer.displayImage("ai2tv_loading.jpg");	Client.out.println(_neededFrame.getNum() + ".jpg was not downloaded in time for showing!");      }    }      // for goodness measurements    if ((((int)(now/1000))%5) == 0 && !thisTime.equals(lastTime)){      int frameNum = 0;      if (_currentFrame != null)	frameNum = _currentFrame.getNum();      goodness.println(systemNow + "\t" + thisTime + "\t" + _level + "\t" + frameNum );      lastTime = thisTime;    }    if (thisTime.equals("5:0"))      System.exit(0);  }  // --------- ClientEffector initiated actions ---------- //  /**   * change viewing/downloading hierarchy level for the client   *   * @param newLevel: new level to set the client to   */  public void changeLevel(int newLevel) {    Client.debug.println("Client setting new level: " + newLevel);    if (0 <= newLevel && newLevel <= _framesData.length)    _level = newLevel;    checkReserveFrames();    // if the cache controller's not doing what it's supposed to be doing, interrupt it.    if (_cache.getNextFrame(_level, currentTime()).getNum() != _cache.getCurrFrame().getNum())      _cache.interruptDownload(false);  }  /**   * change viewing/downloading hierarchy level for the cache controller   *   * @param newLevel: new level for the cache controller   */  public void changeCacheLevel(int newLevel) {    Client.debug.println("CacheController setting new level: " + newLevel);    if (0 <= newLevel && newLevel <= _framesData.length)      _cache.setLevel(newLevel);    checkReserveFrames();    // if the cache controller's not doing what it's supposed to be doing, interrupt it.    if (_cache.getNextFrame(_level, currentTime()).getNum() != _cache.getCurrFrame().getNum())      _cache.interruptDownload(false);  }  /**   * check whether we should switch to or from reserve frames   */  private void checkReserveFrames(){    if (_level != _cache.getLevel() && _reserveFrames == 0)      _reserveFrames = _cache.getNumPrefetchedFrames(_level);    else       _reserveFrames = 0; // reset the reserve frames if the levels are the same  }    /**   * tell the cache controller to jump to this frame.   */  public void jumpTo(String newFrame) {    if (!_adjustingClient){      _adjustingClient = true;      _neededFrame = _framesInfo.getFrame(_level, Integer.parseInt(newFrame));      _cache.jumpTo(newFrame);      _viewer.setNewFrame(true);      _viewer.displayImage(_cacheDir + newFrame + IMAGE_FORMAT);      _adjustingClient = false;        }  }  /**   * @return whether the client is being adjusted (frame wise)   */  public boolean adjustingClient() {    return _adjustingClient;  }    // --------- END: ClientEffector initiated actions ---------- //  // --------- Comm initiated actions ---------- //  /**   * CommController's interface to tell the client that a play was pressed   *   * @param absTimeSent: absolute system time at which the command was originally sent   */  public void commPlay(long absTimeSent) {    _clock.startTime(absTimeSent);    startViewerThread();  }  /**   * CommController's interface to tell the client that a stop was pressed   */  public void commStop() {    Client.out.println("commStop received");    _isActive = false;    _clock.reset();  }  /**   * CommController's interface to tell the client that a pause was pressed   *   * @param absTimeSent: absolute system time at which the command was originally sent   */  public void commPause(long absTimeSent) {    Client.out.println("commPause received");    _clock.pauseTime(absTimeSent);  }  /**   * CommController's interface to tell the client that a goto slider action occured   *   * @param absTimeSent: absolute system time at which the command was originally sent   */  public void commGoto(long absTimeSent, int newTime) {    Client.out.println("commGoto received");    _clock.gotoTime(absTimeSent, newTime);  }  // ------- END: Comm initiated actions ------- //  // --------- Viewer/CHIME initiated actions ---------- //  /**   * send the communications controller the news that everybody   * needs to start playing   */  void playPressed() {    if (!_isActive)      _comm.playPressed();  }  /**   * send the communications controller the news that everybody   * needs to stop   */  void stopPressed() {    if (_isActive)      _comm.stopPressed();  }  /**   * send the communications controller the news that everybody   * needs to pause   */  void pausePressed() {    if (_isActive)      _comm.pausePressed();  }  /**   * send the communications controller the news that everybody   * needs to goto the given time.   *   * @param time: time to goto   */  void gotoPressed(int time) {    _comm.gotoPressed(time);  }  // --------- END: Viewer initiated actions ---------- //  public static void main(String[] args) {    Client c = new Client();  }}